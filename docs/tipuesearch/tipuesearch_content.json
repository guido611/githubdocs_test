{"pages":[{"title":"edaviz","text":"edaviz is a library that helps you getting faster insight into your data without having to leave your python environment. Please do give us feedback on the library. We want to continuously improve the library, and with your support, we can create something truly powerful for the community. But enough for now. We hope you enjoy using edaviz as much as we enjoyed developing it.","tags":"","url":"index.html"},{"title":"Getting Started","text":"edaviz edaviz - Python library for Exploratory Data Analysis and Visualization in Jupyter Notebook or Jupyter Lab Installation Usage API Installation Currently, we are in private access mode. You will receive the initial pip install command and your license directly from us when you have been chosen for early access. The installation consists of 4 steps: 1) pip install From the terminal, you can install edaviz with the pip command that you received from us via mail. 2) setup jupyter extensions Jupyter Notebook From the terminal, you need to setup the Jupyter Notebook extensions via the following commands: jupyter nbextension enable --py widgetsnbextension jupyter nbextension enable --py qgrid If this worked for you, you can continue with step 3. Jupyter Lab Small tip: The setup process with Jupyter Notebook is faster and easier than with Jupyter Lab. Also, JupyterLab 1.0.1 does not work yet, because there are still dependency incompatibilities. However, it works with the latest JupyterLab version before 1.0 If you use Jupyter Lab, you need to use the following commands from your terminal. The Jupyter Lab Extension manager will not work because the version numbers cannot be fixed yet. Important: Jupyter Lab extensions require that you have nodejs installed on your computer. Official install guide for Jupyter Lab Extensions jupyter labextension install @jupyter-widgets\/jupyterlab-manager@0.38 --no-build jupyter labextension install plotlywidget@0.11.0 --no-build jupyter labextension install @jupyterlab\/plotly-extension@0.18.2 --no-build jupyter labextension install qgrid@1.1.1 --no-build jupyter lab build If this worked for you, you can continue with step 3. If you have troubles with the correct display of the edaviz widgets, please validate again, that you have the right versions of the pip dependencies installed because some version combinations are incompatible: From the terminal, you need to enter: (maybe you use pip3?) pip install jupyterlab==0.35.6 pip install ipywidgets==7.4.2 pip install plotly==3.10.0 3) start edaviz in Jupyter From the terminal, start your Jupyter Notebook (or Jupyter Lab): jupyter notebook From a Jupyter cell, you need to start edaviz via the following Python code: import edaviz as eda df = eda.get_titanic_df() # sample pandas dataframe df 4) enter your license If everything works fine, edaviz asks you for a license. Please enter the license key which you received from us. Usage First, start your Jupyter Notebook from the terminal: jupyter notebook Then, execute the following code in a Jupyter cell: import edaviz as eda df = eda.get_titanic_df() # sample pandas dataframe df Info: edaviz only works within Jupyter Notebook or Jupyter Lab. Currently, you cannot use it on other platforms, e.g. via the command line or in PyCharm etc API You will be able to discover most of the library functions via the eda.plot(df) widget. If you want to dig deeper into our docs, you can find them here. 5 most important functions: The best API is no API. Just execute df (or the name of your pandas dataframe object) and see what happens. If you imported edaviz, it will add some interactive visualizations to your pandas dataframe eda.plot(df) shows an overview widget of a given dataframe. This is the main entry point of the edaviz library eda.plot(df, x) shows a suitable univariate summary of a given column, e.g. eda.plot(df, &quot;Age&quot;) eda.plot(df, x, y) shows a suitable bivariate plot of the two columns, e.g. eda.plot(df, &quot;Survived&quot;, &quot;Age&quot;). eda.patterns(df) answers the question: &quot;between which columns exist predictive patterns?&quot; The big advantage of eda.plot is that you do not have to specify the chart type because a best practice visualization is inferred based on the column data types.","tags":"","url":"Getting_Started.html"},{"title":"exporting your results","text":"How to export your results in Jupyter notebooks with edaviz widgets There are two types of exports possible: static HTML export which is easy and fast interactive Jupyter Notebook export which is interactive and powerful 1) Static HTML export PLEASE NOTE: currently .html exports are only possible via Jupyter Notebook and not via Jupyter Lab because there are some dependency incompatibilities. A static .html export can only render static content and it cannot perform background calculations because no Python Kernel is available. For example, this means: The edaviz histogram can be shown but the auto-rebinning does not work. The .html export only contains widgets which you already loaded. So, if you did not calculate the predictors for a given column, then this widget will not be available in the export. If the plotly widget is interactive and shows some tooltips, those will still work. But if the interaction needs some further calculation, this will only work with a full interactive jupyter notebook export (see section 2 for more info). This export is helpful if you know which plots you want to share and if you already generated them. Sometimes, there might be small styling differences if some .css files are missing in the export. Here is how you can generate a static .html export in 3 steps: 1.1) Install the latest version of nbconvert You need to install an upgraded nbconvert library. From the terminal, execute the following pip (or pip3) command: pip install nbconvert==5.5.0 1.2) Create the .html export Create your Notebook via the Jupyter Notebook interface. Unfortunately, this step is currently not possible with Jupyter Lab. After you finished creating your notebook, go to the main menu &quot;Widgets&quot; and press &quot;Save Notebook Widget State&quot;. Let's assume your notebook is called my_notebook.ipynb Afterwards, from the terminal, execute the following command: jupyter nbconvert --to html my_notebook.ipynb This will generate a my_notebook.html file in your current directory. 1.3) Share the .html file You can share the .html file to anyone. In order to view the file, they need 2 things: a web browser an internet connection because the .html file has some dependencies which need to be downloaded from the internet Also, please note that it might take around 2-10 seconds after opening the file until the widgets are displayed. This delay is the time until the browser downloads the needed javascript files. If your internet connection is fast, this might only take 1 second. 2) Interactive Jupyter Notebook export This type of export provides a full Python Kernel. This means, that the observer can use the full power of Jupyter Notebooks and generate new calculations. Since edaviz is build on top of ipywidgets, it is possible to generate an interactive export of your Jupyter Notebook as a live web app, using voila. Please note, that voila is still under development but you can already find tutorials on the repository. https:\/\/github.com\/QuantStack\/voila","tags":"","url":"Next_Level_Shit\/exporting_your_results.html"},{"title":"predictive power score","text":"Introducing the Predictive Power Score (PPS) Stop searching for correlation and start searching for predictive power! The PPS answers the following question: How well can a given column predict another column? It replaces a variety of methods for finding predictive power like correlation, ANOVA or Cramer's V. Also, it is faster than wrapper methods like fitting a Random Forest and inspecting feature importances. The advantages in a nutshell: The PPS is suitable because it can find both linear and non-linear patterns (correlation can only find linear patterns) The PPS is flexible because it can be applied to both numeric and categoric columns (you don't need to choose from various methods like correlation, ANOVA, Cramer's V etc because the predictive power score can handle all those cases) The PPS is faster than fitting a model (e.g. a Random Forest or SVM) The PPS is convenient because you don't need to transform your columns (e.g. most models require some transformation) Description The predictive power score can be described as follows: The score is calculated between 2 columns: a feature column and a target column. The score measures how well the feature column can predict the target column. The score always ranges from 0 to 1 and the score is defined for both numeric and categoric variables. If the score is 0, the feature is not better than a naive predictor, e.g. the naive predictor might always predict the most common value of the target, or the median of the target. If the score is 1, the feature can perfectly predict the target. Most of the times, the score is between 0 and 1. The score that is reported is generalized based on a similar method to crossvalidation. So, the score is tested out-of-sample and not in-sample. The score is based on a specific learning algorithm which can detect nonlinear patterns. If you cannot reproduce the predictive power of a feature in one of your own models (e.g. a linear regression), then maybe your model is not suitable enough for the problem or cannot model non-linear relationships. Usage and Comparison to existing approaches The predictive power score can be used for several use cases. The most common use cases are Feature Selection and Finding Patterns. Feature Selection: a typical application scenario is to find the best univariate predictors\/features for a given target. Is is especially useful if you have many potential features e.g. when you auto-generate features with tsfresh and featurelabs or when you try to find predictive patterns in external data. The score is faster than fitting a classical model like a Random forest. Also, it does not have many of the problems of feature importances. Finding Patterns: another scenario is to find predictive patterns between variables via calculating all pairwise predictive power scores as a patterns matrix. The patterns matrix is better than a correlation matrix because the correlation score is symmetric and cannot find nonlinear patterns. You might find some surprises, if you have a look at the patterns matrix of the Titanic data set.","tags":"","url":"Next_Level_Shit\/predictive_power_score.html"},{"title":"api","text":"Before you read the docs We implemented edaviz in a way so that it is as user-friendly as possible. The best way to learn the api is to call eda.plot(df) and click through the tabs. For each module, we display the code that produced the output. Simply copy-paste the code into another Jupyter cell if you want to play around with the functions. edaviz.plot(df, x=None, y=None, target=None) Shows either an overview of the whole data frame, a univariate or a bivariate plot. Example import edaviz as eda df = eda.get_titanic_df() # overview case eda.plot(df) # for general overview eda.plot(df, target=&quot;Survived&quot;) # for overview with focus on a target # univariate summary eda.plot(df, &quot;Age&quot;) # shows a univariate summary of the &quot;Age&quot; column # bivariate plot eda.plot(df, &quot;Sex&quot;, &quot;Survived&quot;) # shows a bivariate plot of &quot;Survived&quot; against &quot;Sex&quot; eda.patterns(df) Shows an interactive heatmap comparing all columns with each other. It is like a correlation matrix, but uses a predictive power score instead. Example import edaviz as eda df = eda.get_titanic_df() eda.patterns(df) eda.correlations(df) 'eda.correlations' shows an interactive correlation matrix. By clicking on an element of the matrix, you can visualize the bivariate relationship between two columns. Example import edaviz as eda df = eda.get_titanic_df() eda.correlations(df) eda.predictors(df, target) This function let's you inspect the best univariate predictors for a given target variable. Example import edaviz as eda df = eda.get_titanic_df() eda.predictors(df, target=&quot;Survived&quot;) eda.columns(df) eda.columns() provides you with a graphical interface that allows you to quickly look at univariate summaries of your columns. Since it is a correlation matrix, columns of non-numeric types (such as strings) are excluded from the computation. Example import edaviz as eda df = eda.get_titanic_df() eda.columns(df)","tags":"","url":"Folder\/api.html"},{"title":"evaluation","text":"How we evaluated that edaviz makes Data Scientists more than 10x faster As you might know, edaviz started as a research project at the University of Karlsruhe. The goal was to increase the speed of Data Scientists during Exploratory Data Analysis (EDA). In order to evaluate the tool in a meaningful way, we asked 20 Data Scientists from 8 companies: What are the most common tasks during data exploration? Those are the 5 most common EDA tasks: How many missing values does the data set contain? In which columns? Univariate overview of a single column Visualization of the joint distribution between 2 columns Which column is a good predictor for a given target? Between which columns exist predictive patterns? So, the direction was clear but the big question was: Is it possible to solve those tasks for various data sets? After months of development, we were very excited to test edaviz in a real business environment. The question was the following: How much faster is a professional Data Scientist with edaviz in comparison to his best default tool? The evaluation was conducted together with 8 professional Data Scientists from the company STATWORX. And the approach was as follows: They were given 2 different data sets which they had never seen before They were asked to perform the 5 most common EDA tasks listed above For the first data set, they used their best default tool For the second data set, they used edaviz They had never seen edaviz before and received 15 minutes of training on a third data set We measured the duration to create the analysis for each task Of course, we permutated both the data sets and the order in which the tools were used Here are the results: On average, the professional Data Scientists performed the 5 most common tasks more than 10x faster with edaviz after 15 minutes of training All results are summarized in the following graph. On the x axis you can see each task. For each task, you can see the distribution of the task durations with and without edaviz. For the tasks 4 and 5, none of the Data Scientists completed the task within 5 minutes (300s) using their best default tool. Let's go through the first result in detail: The median Data Scientist needed 100s to create the analysis for the first task with his best default tool. With edaviz, he needed 2s. And now, it is up to you. How fast can you solve the most common EDA tasks? Did you ever measure yourself?","tags":"","url":"Folder\/evaluation.html"}]}